from flask import Flask, render_template, request
import pandas as pd
import joblib
import numpy as np
import os

app = Flask(__name__)

# Load model and scaler
# These must be generated by running train_model.py first
MODEL_PATH = 'model.pkl'
SCALER_PATH = 'scaler.pkl'
ENCODER_PATH = 'target_encoder.pkl'

model = None
scaler = None
target_encoder = None

def load_artifacts():
    global model, scaler, target_encoder
    if os.path.exists(MODEL_PATH) and os.path.exists(SCALER_PATH):
        model = joblib.load(MODEL_PATH)
        scaler = joblib.load(SCALER_PATH)
        if os.path.exists(ENCODER_PATH):
            target_encoder = joblib.load(ENCODER_PATH)
    else:
        print("Warning: Model artifacts not found. Please run train_model.py first.")

load_artifacts()

# Mapping features to readable names (if needed) or keeping as is.
# The order must match the training data columns exactly.
# Based on the notebook, the columns are:
EXPECTED_COLUMNS = [
    'Marital status', 'Application mode', 'Application order', 'Course',
    'Daytime/evening attendance', 'Previous qualification', 'Previous qualification (grade)',
    'Nacionality', 'Mother\'s qualification', 'Father\'s qualification',
    'Mother\'s occupation', 'Father\'s occupation', 'Admission grade', 'Displaced',
    'Educational special needs', 'Debtor', 'Tuition fees up to date', 'Gender',
    'Scholarship holder', 'Age at enrollment', 'International',
    'Curricular units 1st sem (credited)', 'Curricular units 1st sem (enrolled)',
    'Curricular units 1st sem (evaluations)', 'Curricular units 1st sem (approved)',
    'Curricular units 1st sem (grade)', 'Curricular units 1st sem (without evaluations)',
    'Curricular units 2nd sem (credited)', 'Curricular units 2nd sem (enrolled)',
    'Curricular units 2nd sem (evaluations)', 'Curricular units 2nd sem (approved)',
    'Curricular units 2nd sem (grade)', 'Curricular units 2nd sem (without evaluations)',
    'Unemployment rate', 'Inflation rate', 'GDP'
]

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/dashboard')
def dashboard():
    try:
        # Read data (assuming semicolon delimiter based on file inspection)
        df = pd.read_csv('data.csv', sep=';')
        
        # 1. Key Metrics
        total_students = len(df)
        dropout_count = len(df[df['Target'] == 'Dropout'])
        enrolled_count = len(df[df['Target'] == 'Enrolled'])
        graduate_count = len(df[df['Target'] == 'Graduate'])
        
        dropout_rate = round((dropout_count / total_students) * 100, 1)
        enrolled_rate = round((enrolled_count / total_students) * 100, 1)
        graduate_rate = round((graduate_count / total_students) * 100, 1)
        
        avg_admission_grade = round(df['Admission grade'].mean(), 1)
        
        # 2. Charts Data
        
        # Target Distribution
        target_counts = df['Target'].value_counts()
        target_data = {
            'labels': target_counts.index.tolist(),
            'data': target_counts.values.tolist()
        }
        
        # Gender Distribution by Target
        # Gender: 0=Female, 1=Male
        gender_chart_data = {
            'labels': ['Dropout', 'Enrolled', 'Graduate'],
            'female': [],
            'male': []
        }
        
        for target in gender_chart_data['labels']:
            counts = df[df['Target'] == target]['Gender'].value_counts()
            gender_chart_data['female'].append(int(counts.get(0, 0)))
            gender_chart_data['male'].append(int(counts.get(1, 0)))

        # Age Distribution (Histogram-like)
        # We'll create bins for age
        age_bins = [17, 20, 25, 30, 40, 50, 60]
        age_labels = ['17-20', '21-25', '26-30', '31-40', '41-50', '50+']
        df['AgeGroup'] = pd.cut(df['Age at enrollment'], bins=[0, 20, 25, 30, 40, 50, 100], labels=age_labels)
        age_counts = df['AgeGroup'].value_counts().sort_index()
        
        age_data = {
            'labels': age_counts.index.tolist(),
            'data': age_counts.values.tolist()
        }

        dashboard_data = {
            'total_students': total_students,
            'dropout_rate': dropout_rate,
            'enrolled_rate': enrolled_rate,
            'graduate_rate': graduate_rate,
            'avg_admission_grade': avg_admission_grade,
            'target_chart': target_data,
            'gender_chart': gender_chart_data,
            'age_chart': age_data
        }
        
        return render_template('dashboard.html', data=dashboard_data)
        
    except Exception as e:
        return f"Error loading dashboard data: {str(e)}"

@app.route('/predict', methods=['POST'])
def predict():
    if not model or not scaler:
        return render_template('result.html', prediction_text="Error: Model not loaded. Please train the model first.")

    try:
        # Collect input features in the correct order
        features = []
        for col in EXPECTED_COLUMNS:
            val = request.form.get(col)
            if val is None:
                # Handle missing value or checkbox
                # For checkboxes like 'Displaced', 'Debtor', etc., standard HTML forms might optionally send nothing if unchecked
                # But typically we will design the form to send 0/1. 
                # Assuming text inputs are numeric.
                val = 0 
            features.append(float(val))

        # Reshape and scale
        final_features = np.array([features])
        final_features_scaled = scaler.transform(final_features)

        # Predict
        prediction_idx = model.predict(final_features_scaled)[0]
        
        # Decode prediction
        # Classes: Dropout (0), Enrolled (1), Graduate (2)
        # If we have the encoder, we can use inverse_transform, or just hardcode for this specific dataset
        prediction_text = "Unknown"
        if target_encoder:
            prediction_text = target_encoder.inverse_transform([prediction_idx])[0]
        else:
             mapping = {0: 'Dropout', 1: 'Enrolled', 2: 'Graduate'}
             prediction_text = mapping.get(prediction_idx, "Unknown")

        return render_template('result.html', prediction_text=prediction_text)

    except Exception as e:
        return render_template('result.html', prediction_text=f"Error occurred: {str(e)}")

if __name__ == "__main__":
    app.run(debug=True)
